hash家族天生具有高效的查找，插入删除性能，所以不同的hash实现区别主要在**插入有序性**和**重复性**上。Hash家族的缺点：冲突情况过多时，时间复杂度会恶化到O(n)。

|               | 插入有序性 |   元素重复性   |
| :-----------: | :--------: | :------------: |
|    HashMap    |    无序    |    允许重复    |
|    HashSet    |    无序    | **不允许重复** |
| LinkedHashMap |    有序    |    允许重复    |
| LinkedHashSet |    有序    |   不允许重复   |

1. 哈希链表LinkedHashMap

   ![img](https://labuladong.gitee.io/algo/images/LRU%e7%ae%97%e6%b3%95/4.jpg)

   - 哈希链表由双链表和Hashmap实现。哈希链表综合了Hashmap和链表的优点，具有O(1)的查找性能，O(1)的插入和删除，并保证有序性。

   - 为什么哈希链表使用双链表？

     使用链表可以实现插入有序性，而使用双链表是因为哈希链表删除节点涉及当前节点，前驱节点以及后继节点的指针修改，而只有双向链表可以支持查找前驱结点，保证时间复杂度在O(1)。

2. LinkedHashSet

   - LinkedHashSet由双链表和HashSet实现，而HashSet又由Hashmap实现，所以LinkedHashSet综合了Hashmap和链表的优点，又保证了Set集合的特点(不可重复)，具有O(1)的查找性能，O(1)的插入删除，并保证了有序性和不可重复性。

3. LRU缓存淘汰算法(Least Recently Used，最近最少使用算法)

   - 依据理论：最近使用的页面数据会在未来一段时间内仍然被使用，已经很久未使用的页面很有可能在未来较长一段时间内仍然不会被使用。基于该思想，LRU算法在缓存容量满时，将缓存中最近最久未使用的数据删除，从而存入新数据。
   - 基于哈希链表就可直接实现LRU算法。

4. LFU缓存淘汰算法(Least Frequently Used)

   - 一定时间内被访问次数最少的数据，在将来被访问的几率也是最小。LFU算法更关注数据的访问频率。LFU算法在缓存容量满时，将缓存中最近使用次数最少的数据删除；当使用次数相等时，将插入最早的数据删除。由此可见，LFU算法需要维护数据的使用次数，以及相同使用次数下的插入顺序。

   - 实现LFU算法需要维护记录值的hashmap，记录使用次数的hashmap以及记录相同使用次数下的数据列表。这里记录相同使用次数下的数据列表使用LinkedHashSet，是因为在保证插入有序的前提下做到O(1)的插入删除效率(不保证不重复性的话，也可以用LinkedHashMap)。

     ```java
     Hashmap<String, Value> KeyToVal; //记录值
     Hashmap<String, Integer> KeyToFrequent;//记录使用次数
     Hashmap<Integer, LinkedHashSet<String>> FreToKeys;//记录相同使用次数的数据列表 
     ```

4. 