

1. 递归问题的优化
   
   - 递归嵌套递归时可改成只使用一个递归；
   - 可以对右子树的递归加上限制条件，避免求解成功后执行不必要的右子树递归；
   - 前序遍历是自顶向下解决问题，后序遍历是自底向上解决问题，后序遍历可优化前序遍历；
   - 
   
2. 递归思想解决问题  

   - 问题分解成子问题，父节点的任务转化成左右子树的工作
   - 确定当前节点任务
   - 确定任务时机(前序，中序和后序)。

3. 二叉树递归遍历方式：

   - 前序遍历是**自顶向下(**先操作当前节点后操作左右子树)的干活，后序遍历是**自底向上**(先操作左右子树后操作当前节点)的干活。
   - **如果当前节点做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历**。前序遍历和后序遍历能获取的信息不相同；前序遍历是刚刚进入该节点的时刻，只能获得参数中的数据；后序遍历是即将离开该节点的时刻，可以获得参数和左右子树中的数据。
   - 递归相当于保持了一个访问节点的栈。

4. 迭代模拟递归实现二叉树的三种遍历方式

   - 模拟方法栈，对于每颗子树都是先将左子树节点全部入栈，然后再将右子树节点入栈。

   ![image-20220309114905258](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220309114905258.png)

5. 构造二叉树

   - 根据前序和中序遍历构造二叉树
   - 根据中序和后序遍历构造二叉树

   - **根据前序和后序遍历构造某一二叉树**

   ![img](https://img-blog.csdn.net/20170602093319885?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQyOTQyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   由于前序遍历只能确定根节点的顺序，但是不能确定左右子树的区间。对于上图先序序列[A,B,C]，只能确定A为根节点，不能确定B是左子树根节点还是右子树根节点。所以根据前序和后序遍历构造二叉树，可以假定一种情况(先序序列确定左子树节点)。

6. 怎么快捷保存路径？

   - 从根节点到某节点
   - 从某节点到某节点

7. 