# C++常识

## 编码风格/优化

### using

- `using namespace xxx`一定不要在头文件中使用，nobody会知道包含这个头文件的文件会不会出现命名冲突。
- 如果要使用`using namespace xxx`，请尽可能缩小其作用域，源文件内/函数内/局部代码块
- 如果明确不会出现命名冲突，比如自己的代码中，则可以适当使用`using namespace xxx`


## 变量

- 变量创建过程：申请内存 -> 分配内存 -> 返回指针 -> 变量初始化

### 栈内存和堆内存

- 尽可能使用栈分配内存，除非不能使用栈分配，场景如下：1).变量的生命周期更长 2)变量所需内存过大
  - 栈内存分配时仅仅需要移动栈指针，回收内存时仅需要弹栈，所以内存分配和回收更高效；
  - 堆内存分配时会从空闲列表中查找满足内存大小需求的空闲空间，请求内存，记录内存使用(堆上内存分配慢，要做的事情很多；栈上内存分配快，就像是执行一条CPU指令)
- 注意定义变量时，变量的内存分配是在栈上还是堆上，有三点不同：
    - 其生命周期不同，栈上变量的生命周期持续到函数结束，堆中变量的周期取决于手动回收的时期;
    - 栈上变量的内存分配更快，并且会自动回收变量内存;堆上变量的内存分配更慢，且需要手动回收内存;
    - 栈空间更小，堆空间会增长，大对象只能声明在堆中;

### 指针/引用

- 指针本身没有类型，就是整形的变量，存储的是内存地址。指针的类型只是为了更好的访问读写内存，方便编程的。
- 引用和指针除了使用上的差异本质上并无区别，引用只是语法糖(运行时并不会存在一个引用变量)，引用更简洁，指针更强大更灵活。

### const

- 尽量使用const引用传递对象(避免参数传递时的复制)
- 尽量使用const修饰类中不修改成员变量的方法


### static关键字

保证变量全局的生命周期的同时，限制变量的作用域

- 尽量少用全局变量，多使用static修饰类外部变量和函数，链接时这些变量和函数只会在当前翻译单元有效，相当于把这些变量和函数声明为该文件私有。
- 局部作用域中使用static修饰变量，即在声明一个static变量的基础上(生命周期为程序结束)限制其作用域。场景合适的话，是可以适当使用的。

### const/mutable关键字

- mutable的使用就是为了弥补const成员方法不能修改成员变量的缺陷，另外一种修饰lambda表达式的场景只是为了简化语法，毫无意义

### size_t类型的使用场景

size_t is the result type of the sizeof operator.

**Use size_t for variables that model size or index in an array**. size_t conveys semantics: you immediately know it represents a size in bytes or an index, rather than just another integer.

Also, using size_t to represent a size in bytes helps making the code portable.

## 面向对象 

- new操作符：申请，分配内存，调用构造函数
- 类的已知大小数组成员变量初始化，大小由另外一个常量指定，应该使用static const或者static constexpr(表明该值在编译期就可以确定)

### 对象生存周期

- 对象的生存周期取决于对象是栈上分配还是堆上分配，如果是栈上分配，那么该对象的生存周期通常和代码块的作用域保持一致，并会自动销毁对象。
- 栈对象分配+析构函数可以实现自动回收内存。这部分工作也可以使用智能指针

### 智能指针

智能指针会调用new创建对象

#### 作用域指针`unique_ptr`

- 不能赋值给其他智能指针变量，意味着只能同时存在一个智能指针指向目标内存。
- 使用开销低。

```c++
#include <memory>

int main(){

    //超过该作用域，entity指针指向的内存就会被清理
    {
        //使用make_unique()内部会调用构造函数，是异常安全的
        std::unique_ptr<Example> entity = std::make_unique<Example>();

        std::unique_ptr<Example> entity = std::unique_ptr(new Example());
    }

}
```

#### 共享指针`shared_ptr`

- `shared_ptr`指针基于引用计数实现，指向目标内存的指针数量为零则回收该内存。`shared_ptr`存在一个控制内存块，用于引用计数。
- 有使用开销，适合在对象中共享指针时使用。

```c++
#include <memory>

int main(){

    //超过该作用域，entity指针指向的内存就会被清理
    {
        //直接使用new声明共享指针，会有两次内存分配：new Example()的内存分配，shared_ptr的控制内存块的分配
        std::shared_ptr<Example> entity = std::shared_ptr(new Example());
        //内存分配只有一次，更有效率
        std::shared_ptr<Example> entity = std::make_shared<Example>();

    }

}
``` 

#### 弱指针`wear_ptr`

弱指针可以和共享指针混用，但是弱指针并不会增加引用计数，也并不会检测指向的内存是否有效


 

### 类和结构体

- 区别仅仅是成员变量/函数的默认访问权限不同。类中的成员默认是private，结构体中的成员默认是public。
其他使用并没有差别。

### 类成员初始化列表

```c++ 
class Example{
    private:
        int a;
    public:
        void setA()  : a(10)
        {
        }
}
```

- 尽可能使用初始化列表进行类成员初始化，
    - 可读性更强；
    - 浪费性能。类类型成员会调用无参构造器进行默认初始化，再在类的构造函数中人为初始化一次，会出现两次初始化；

### 隐式转换/explicit

- C++允许编译器进行一次隐式类型转换，可以简化代码，但是尽量少用，可读性差。
- explicit修饰构造函数，用于禁用基于该构造函数的隐式类型转换

```c++ 
class Example{
    private:
        int a;
    public:
        Example(int a){
            this-> a = a;
        }
}


int main(){
    Example example(20);
    Example example = 20; //做了一次隐式类型转换，实际调用的是带参构造函数
}
```


### 多态/虚函数

- 虚函数的代价包括维护虚函数表和查表，但是虚函数可以适当使用，除非是嵌入式等性能特别弱的场景

### 运算符重载

避免滥用，合理利用运算符重载，提供代码可读性和便捷性。编写新方法也可以替代重载运算符，是否重载运算符取决于编码风格，当然也可以两者都提供。
运算符可以重载的场景：
- 数值类型的类的加减乘除：`+ - * /`
- 左移运算符 `<<`，相当于Java中重写toString()
- 比较运算符 `==`，相当于Java中重写equals()

### 字符串

- 字符串字面量实际上是const char[]或者const char*
- 为了标识字符串在内存中的终止，字符数组的最后一位需要时终止字符`\0`


## STL

### 静态数组`array`

相比于c语言数组`int[]`, 更应该使用静态数组array类。
- array类有debug模式下的边界检查
- array类可以使用STL提供的各种算法
- array类记录了数组大小，但是它并不维护这个大小(基于模板实现，其Size()直接返回数值大小)，因此没有性能消耗。

### 动态数组`vector`

- vector**存储对象比存储对象指针更高效**，但是扩容时效率更低
    - vector存储对象时使用的是连续内存，基于缓存局部性原理， 同一数组可以被一次性加载高速缓存中，相比于存储对象指针访问更高效；
    - 由于vector存储对象所需的连续内存空间比存储指针大得多，因此扩容时内存分配和复制效率更低；  
- 使用vector时可以**提前设置vector的大小**`arr .reserve(3)`，可以减少复制次数，提高使用vector的效率

### 元组`tuple`

类型不同的多返回值，有以下解决办法：
- 返回值类型为void，在外部将引用作为参数传递给函数
- 返回值类型为元组tuple
- 返回值类型为结构体(推荐)

## 模板

- **模板只是人为定义的规则，不是真正的代码，只有调用模板时编译器基于规则才会生成相应模板函数/类的代码。**
- 模板的类型参数可以是`typename T`也可以是实际类型`int`
- 模板是魔法，但是过度使用模板会极大地降低代码的可读性，因此在合适的场景适当地使用模板。

### C++中模板和Java中泛型的区别


## 类型推导

### auto变量

如果变量类型很长，影响可读性的情况下可以适当使用auto。 

### 

## 宏macro

宏本质就是预处理阶段的文本替换工作。宏常用于调试(条件判断)/日志/函数调用。

### 宏和模板的区别

## lambda

### lambda表达式

lambda函数即匿名函数，一次性函数，用完即丢。lambda函数格式`[](int val){ }`

### 函数指针

类似Java中的函数式接口，用来接收lambda表达式。函数指针定义：`void(*function)();`。

- 尽量使用`typedef void(*function)();`或者`using function=void(*function)()`声明函数指针变量


### `std::Function`

接受lambda表达式。
