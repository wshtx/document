# C++常识


## 变量

- 变量创建过程：申请内存 -> 分配内存 -> 返回指针 -> 变量初始化

### union共用体

共用体中的成员共享同一块内存。



### 动态分配和自动分配

*要遵循RAII(Resource acquisition is initialization,资源获取即初始化)原则，有助于简化资源管理，保证程序正确性。在 RAII 中，持有资源是类的不变式，并与对象的生命周期挂钩。资源分配（或获取）由构造函数在对象创建（特别是初始化）过程中完成，而资源解除分配（释放）则由析构函数在对象销毁（特别是最终化）过程中完成。*

动态分配：使用new在堆上分配内存。
自动分配：在作用域中在栈上自动分配回收内存。

- 尽可能使用栈分配内存，除非不能使用栈分配，场景如下：1).变量的生命周期更长 2)变量所需内存过大
  - 栈内存分配时仅仅需要移动栈指针，回收内存时仅需要弹栈，所以内存分配和回收更高效；
  - 堆内存分配时会从空闲列表中查找满足内存大小需求的空闲空间，请求内存，记录内存使用(堆上内存分配慢，要做的事情很多；栈上内存分配快，就像是执行一条CPU指令)
- 注意定义变量时，变量的内存分配是在栈上还是堆上，有三点不同：
    - 其生命周期不同，栈上变量的生命周期持续到函数结束，堆中变量的周期取决于手动回收的时期;
    - 栈上变量的内存分配更快，并且会自动回收变量内存;堆上变量的内存分配更慢，且需要手动回收内存;
    - 栈空间更小，堆空间会增长，大对象只能声明在堆中;

### 指针/引用

- 指针本身没有类型，就是整形的变量，存储的是内存地址。指针的类型只是为了更好的访问读写内存，方便编程的。
- 引用和指针除了使用上的差异本质上并无区别，引用只是语法糖(运行时并不会存在一个引用变量)，引用更简洁，指针更强大更灵活。


### 类型双关

c++中可以自由访问内存。在已知内存地址的情况下，向后取几个字节并解释成什么类型都很自由，但也很危险。

```c++
struct Example{
    int x,y;
};

int main(){
    Example example = {5,6};
    int tmp = *(int*)((char*)&example+4)
    std::cout << tmp << std::endl;
}
```




### static关键字

static修饰外部变量可以保证变量全局的生命周期的同时，限制变量的作用域

- 尽量少用全局变量，多使用static修饰类外部变量和函数，链接时这些变量和函数只会在当前翻译单元有效，相当于把这些变量和函数声明为该文件私有。
- 局部作用域中使用static修饰变量，即在声明一个static变量的基础上(生命周期为程序结束)限制其作用域。场景合适的话，是可以适当使用的。

### const/mutable关键字

- mutable的使用就是为了弥补const成员方法不能修改成员变量的缺陷，另外一种修饰lambda表达式的场景只是为了简化语法，毫无意义

### size_t类型的使用场景

size_t is the result type of the sizeof operator.

**Use size_t for variables that model size or index in an array**. size_t conveys semantics: you immediately know it represents a size in bytes or an index, rather than just another integer.

Also, using size_t to represent a size in bytes helps making the code portable.

## 面向对象 

- new操作符：申请，分配内存，调用构造函数
- 类的已知大小数组成员变量初始化，大小由另外一个常量指定，应该使用static const或者static constexpr(表明该值在编译期就可以确定)

### 对象生存周期

- 对象的生存周期取决于对象是栈上分配还是堆上分配，如果是栈上分配，那么该对象的生存周期通常和代码块的作用域保持一致，并会自动销毁对象。
- 栈对象分配+析构函数可以实现自动回收内存。这部分工作也可以使用智能指针

### 智能指针

智能指针会调用new创建对象

#### 作用域指针`unique_ptr`

- 不能赋值给其他智能指针变量，意味着只能同时存在一个智能指针指向目标内存。
- 使用开销低。

```c++
#include <memory>

int main(){

    //超过该作用域，entity指针指向的内存就会被清理
    {
        //使用make_unique()内部会调用构造函数，是异常安全的
        std::unique_ptr<Example> entity = std::make_unique<Example>();

        std::unique_ptr<Example> entity = std::unique_ptr(new Example());
    }

}
```

#### 共享指针`shared_ptr`

- `shared_ptr`指针基于引用计数实现，指向目标内存的指针数量为零则回收该内存。`shared_ptr`存在一个控制内存块，用于引用计数。
- 有使用开销，适合在对象中共享指针时使用。

```c++
#include <memory>

int main(){

    //超过该作用域，entity指针指向的内存就会被清理
    {
        //直接使用new声明共享指针，会有两次内存分配：new Example()的内存分配，shared_ptr的控制内存块的分配
        std::shared_ptr<Example> entity = std::shared_ptr(new Example());
        //内存分配只有一次，更有效率
        std::shared_ptr<Example> entity = std::make_shared<Example>();

    }

}
``` 

#### 弱指针`wear_ptr`

弱指针可以和共享指针混用，但是弱指针并不会增加引用计数，也并不会检测指向的内存是否有效


 

### 类和结构体

- 区别仅仅是成员变量/函数的默认访问权限不同。类中的成员默认是private，结构体中的成员默认是public。
其他使用并没有差别。

### 类成员初始化列表

```c++ 
class Example{
    private:
        int a;
    public:
        void setA()  : a(10)
        {
        }
}
```

- 尽可能使用初始化列表进行类成员初始化，
    - 可读性更强；
    - 浪费性能。类类型成员会调用无参构造器进行默认初始化，再在类的构造函数中人为初始化一次，会出现两次初始化；

### 隐式转换/explicit

- C++允许编译器进行一次隐式类型转换，可以简化代码，但是尽量少用，可读性差。
- explicit修饰构造函数，用于禁用基于该构造函数的隐式类型转换

```c++ 
class Example{
    private:
        int a;
    public:
        Example(int a){
            this-> a = a;
        }
}


int main(){
    Example example(20);
    Example example = 20; //做了一次隐式类型转换，实际调用的是带参构造函数
}
```


### 类型转换

c++风格的四种类型转换会做编译时检查，dynamic_case()会做运行时检查，代码更可靠：
- static_cast()
- const_cast() 移除/添加变量的const限定
- reinterpret_cast() 把某段内存解释成指定类型的数据
- dynamic_cast() 专门用于基于继承层次的强制类型转换
程序额外存储RTTI(运行时类型信息Runtime Type Information)来实现类型转换，有开销。
 

### 多态/虚函数

- 虚函数的代价包括维护虚函数表和查表，但是虚函数可以适当使用，除非是嵌入式等性能特别弱的场景

### 虚析构函数

在明确某个基类存在派生类时，必须要指定基类析构函数为virtual，防止使用多态时未调用派生类析构函数而造成的内存泄漏

```c++
class Base{
    Base(){
        std::cout << "Base Constructor\n" << std::endl;
    }

    ~Base(){
        std::cout << "Base Deconstructor" << std::endl;
    }

    // virtual ~Base(){
    //     std::cout << "Base Deconstructor" << std::endl;
    // }

}

class Derived: public Base{
    Derived(){
        std::cout << "Derived Constructor\n" << std::endl;
    }

    ~Derived(){
        std::cout << "Derived Deconstructor\n" << std::endl;
    }
}

int main(){

    //正常调用Base构造函数和析构函数
    Base* base =new Base();
    delete base;
    std::cout << "-----------------" << std::endl;

    //正常调用Derived构造函数和析构函数
    //派生类的构造函数和析构函数会先调用基类的构造函数和析构函数
    Derived* derived = new Derived();
    delete derived;
    std::cout << "-----------------" << std::endl;

    //调用Derived构造函数
    Base* poly = new Derived();
    //析构函数没有标记成virtual时，poly的析构函数就是基类Base的析构函数
    //析构函数标记成virtual后，由于多态，poly的析构函数就是派生类Derived的析构函数
    delete poly;

}


```

### 运算符重载

避免滥用，合理利用运算符重载，提供代码可读性和便捷性。编写新方法也可以替代重载运算符，是否重载运算符取决于编码风格，当然也可以两者都提供。
运算符可以重载的场景：
- 数值类型的类的加减乘除：`+ - * /`
- 左移运算符 `<<`，相当于Java中重写toString()
- 比较运算符 `==`，相当于Java中重写equals()

### 运算符和构造函数的区别

构造函数是对象不存在是，用来调用创建对象的。操作符更类似一种成员函数，比如赋值运算符`=`，需要对象已创建才能进行调用`object.operate=()`。

### 字符串

- 字符串字面量实际上是const char[]或者const char*
- 为了标识字符串在内存中的终止，字符数组的最后一位需要时终止字符`\0`


## STL

### 静态数组`array`

相比于c语言数组`int[]`, 更应该使用静态数组array类。
- array类有debug模式下的边界检查
- array类可以使用STL提供的各种算法
- array类记录了数组大小，但是它并不维护这个大小(基于模板实现，其Size()直接返回数值大小)，因此没有性能消耗。

### 动态数组`vector`

- vector**存储对象比存储对象指针更高效**，但是扩容时效率更低
    - vector存储对象时使用的是连续内存，基于缓存局部性原理， 同一数组可以被一次性加载高速缓存中，相比于存储对象指针访问更高效；
    - 由于vector存储对象所需的连续内存空间比存储指针大得多，因此扩容时内存分配和复制效率更低；  
- 使用vector时可以**提前设置vector的大小**`arr .reserve(3)`，可以减少复制次数，提高使用vector的效率

### 元组`tuple`

类型不同的多返回值，有以下解决办法：
- 返回值类型为void，在外部将引用作为参数传递给函数
- 返回值类型为元组tuple/pair/tie
- 返回值类型为结构体(推荐)

### 排序算法

```c++
#include <vector>
#include <algorithm>

std::vector<int> arr = {3,5,1,4,2};
std::sort(arr.begin(),arr.end(),[](int a,int b){
    //1总是放在最后
    if(a == 1)
    return false;
    if(b == 1)
    return true

    return a > b;//true则交换元素
})
```

## 模板

- **模板只是人为定义的规则，不是真正的代码，只有调用模板时编译器基于规则才会生成相应模板函数/类的代码。**
- 模板的类型参数可以是`typename T`也可以是实际类型`int`
- 模板是魔法，但是过度使用模板会极大地降低代码的可读性，因此在合适的场景适当地使用模板。

### C++中模板和Java中泛型的区别

## 宏macro

宏本质就是预处理阶段的文本替换工作。宏常用于调试(条件判断)/日志/函数调用。

### 宏和模板的区别

## lambda

### lambda表达式

lambda函数即匿名函数，一次性函数，用完即丢。lambda函数格式`[](int val){ }`

### 函数指针

类似Java中的函数式接口，用来接收lambda表达式。函数指针定义：`void(*function)();`。

- 尽量使用`typedef void(*function)();`或者`using function=void(*function)()`声明函数指针变量


### `std::Function`

接受lambda表达式。


## 多线程

```c++
#include <thread>

//创建worker线程，提供function函数
std::thread worker(function);
//阻塞当前线程直到worker线程结束
worker.join();

//当前线程睡眠1s
using namespace std::literals::chrono_literals;
std::this_thread::sleep_for(1s);


```

## 日期时间

### 计时|chrono库

- 时钟clock
- 时间间隔duration
- 时间点time_point

自定义作用域计时器，统计代码耗时操作如下：
```c++
#include <chrono>
class Timer{
    public:

    Timer(){
        _startTimePoint = std::chrono::high_resolution_clock::now();
    }
    ~Timer(){
       Stop();
    }

    void Stop(){
        auto endTimePoint = std::chrono::high_resolution_clock::now();

        auto start = std::chrono::time_point_cast<std::chrono::microseconds>(_startTimePoint).time_since_epoch().count();

        auto end = std::chrono::time_point_cast<std::chrono::microseconds>(endTimePoint).time_since_epoch().count();

        auto duration = start - end;
        auto ms  = duration * 0.03
        sstd::cout << duration << "us(" << ms <<" us)" << std::endl;
    }

    private:
        std::chrono::time_point<std::chrono::high_resolution_clock> _startTime;
}

class Example{

}

int main(){

    std::count << "Timer make unique_ptr" << std::endl;
    {
        Timer timer;
        std::array<std::unique_ptr<Example>> uniquePtrs;
        for(int i = 0; i < 1000; i++)
            uniquePtrs[i] = std::make_unique<Example>();
    }
    
    std::count << "Timer make shared_ptr" << std::endl;
    {
        Timer timer;
        std::array<std::shared_ptr<Example>> sharedPtrs;
        for(int i = 0; i < 1000; i++)
            uniquePtrs[i] = std::make_shared<Example>();
    }

    std::count << "Timer new unique_ptr" << std::endl;
    {
        Timer timer;
        std::array<std::shared_ptr<Example>> sharedPtrs;
        for(int i = 0; i < 1000; i++)
            uniquePtrs[i] = std::shared_ptr<Example>(new Example);
    }

}
```
